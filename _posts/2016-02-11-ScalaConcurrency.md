---
layout: page
title: Scala并发编程
time: 2016-02-12 20:33:00
---

在Java编程里面，并发编程一直被看作是一门高大上的内容。主要原因在于编写正确的并发程序相对于单线程程序来说，基本上难出一个数量级。又由于Java相对来说比较啰嗦，编写并发程序的时候又会导致额外的代码，所以部分人不太愿意写并发程序。但是随着现代计算机往多核发展，应用可能服务的用户数量成几何指数增加，为了更好地利用硬件资源，所以编写并发程序，应该要成为程序员的基本素养。

Scala赖以成名的一大优点就是其对并发编程的高级抽象。借助于Scala的函数式的特性，编写并发程序变得前所未有的轻松简单。当然，在这之前，还是必须了解并发编程需要解决什么样的问题，并且横向地和Java做一下对比，这样我们才能知道，为什么Scala在这一块有优势。

### 1. 什么是并发

在单核CPU时代，对于并发的要求并不是很高。因为只有一个CPU，强行加入过多的线程进行并发的话，可能会导致较多的线程之间的上下文切换开销，从而使得程序的性能急剧下降，得不偿失。那时候并发的场景主要在于IO出现的时候。当程序需要进行一个类似于文件读取的操作的时候，比较好的模式是新起一个线程去进行这个操作，然后再在IO完成的时候，做下一步动作。之所以这样做，主要是因为IO读取的操作速度相对于CPU计算速度来说，实在是太慢。[下表](http://norvig.com/21-days.html#answers)给出了一个大致的估计：

-----|--------
CPU执行一般的指令|1/1,000,000,000 sec = 1 nanosec
从L1缓存读取数据|0.5 nanosec
[分支预测错误](https://en.wikipedia.org/wiki/Branch_misprediction)|5 nanosec
从L2缓存读取数据|7 nanosec
互斥锁/解锁|25 nanosec
从主存读取数据|100 nanosec
通过千兆网络发送2KB数据|20,000 nanosec
从主存顺序读取1MB的数据|250,000 nanosec
硬盘寻址|8,000,000 nanosec
从硬盘顺序读取1MB的数据|20,000,000 nanosec
从美国向欧洲发送数据包|150 milliseconds = 150,000,000 nanosec


