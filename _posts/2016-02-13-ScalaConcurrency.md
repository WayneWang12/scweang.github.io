---
layout: page
title: Scala并发编程
time: 2016-02-13 20:33:00
---

在Java编程里面，并发编程一直被看作是一门高大上的内容。主要原因在于编写正确的并发程序相对于单线程程序来说，基本上难出一个数量级。又由于Java相对来说比较啰嗦，编写并发程序的时候又会导致额外的代码，所以部分人不太愿意写并发程序。但是随着现代计算机往多核发展，应用可能服务的用户数量成几何指数增加，为了更好地利用硬件资源，编写并发程序，应该要成为程序员的基本素养。

Scala赖以成名的一大优点就是其对并发编程的高级抽象。借助于Scala的函数式的特性，编写并发程序变得前所未有的轻松简单。当然，在这之前，还是必须了解并发编程需要解决什么样的问题，并且横向地和Java做一下对比，这样我们才能知道，为什么Scala在这一块有优势。

### 1. 什么是并发编程

远古时代的计算机不包含操作系统，它们从头到尾只执行一个程序，并且这个程序能访问计算机中的所有资源。在这种裸机环境里面，不仅很难编写和运行程序，而且每次运行只能有一个程序，这对于昂贵并且稀有的计算机资源来说也是一种浪费。而[操作系统](https://zh.wikipedia.org/zh-cn/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F)的出现使得计算机每次能运行多个程序，并且不同的程序都在单独的进程中运行。操作系统会为各个独立执行的进程分配各种资源，包括内存、文件句柄以及安全证书等。如果需要的话，不同的进程还能通过一些粗粒度的通信机制来交换数据，这些机制包括：套接字、信号处理器、共享内存、信号量以及文件等。

之所以在计算机中加入操作系统来实现多个程序的同时执行，主要是基于以下三个原因：

1. 资源利用率：很多情况下，程序必须等待某个外部操作执行完成，例如输入输出操作，而在等待的时候程序无法执行其他任何工作。因此如果在等待的同时可以运行另一个程序，那么无疑可以提高`资源利用率`；
2. 公平性：不同的用户和程序对于计算机上的资源有着同等的使用权，应当保障这些用户和程序能够共享计算机资源，而不是由一个程序从头运行到尾，然后再启动下一个程序；
3. 便利性：通常来说，在计算多个任务的时候，应该编写多个程序，然后在必要的时候相互通信，这比只编写一个程序来计算所有任务更容易实现。

而为了实现以上三点，操作系统提供了[进程](https://zh.wikipedia.org/wiki/%E8%A1%8C%E7%A8%8B)的概念来运行程序。这就保证了计算机的资源在运行的过程中能得到合理的利用，多个程序运行在多个进程里面，然后由操作系统决定哪一个进程占用CPU资源。

但是，仅仅只有进程是不够的。进程负责运行程序，而程序通常可能会有不同的执行路径。如果操作系统是以进程为单位进行调度的话，就意味着每一个CPU时间片里面，程序只能有一条路径得到执行，而这就阻止了[异步方法调用](https://zh.wikipedia.org/wiki/%E5%BC%82%E6%AD%A5%E6%96%B9%E6%B3%95%E8%B0%83%E7%94%A8)的可能性。异步方法调用是实现并发的重要手段。在程序进行了一次异步调用之后，就在程序执行的过程中产生了两条路径。就好比，你打开热水壶烧水，然后开始玩手机。这个时候不仅水在慢慢烧开，你也从玩手机的过程中得到了快感。然后当热水壶把水烧开了以后，会自动关闭或者产生声音通知你，然后你就可以泡壶茶，再继续玩手机。这种情形下，你打开热水壶的操作就是一个异步的方法调用。你在相同的时间里面完成了两件事情，而这主要归功于热水壶帮你处理了其中一件，并且在完成了以后及时通知了你。可是假设你和热水壶是一个计算机里面的两个模块(你是CPU，热水壶是[DMA](https://zh.wikipedia.org/wiki/%E7%9B%B4%E6%8E%A5%E8%A8%98%E6%86%B6%E9%AB%94%E5%AD%98%E5%8F%96))，玩手机和烧水是一个程序里面的两条路径，并且由于操作系统只能按照进程进行调度，所以当轮到你的程序得到调度的时候，要么是你在玩手机，要么是热水壶在烧水。明明是可以同时执行的两个任务，却只能依次来做，实在令人郁闷。而为了解决这个问题，伟大的计算机科学家们发明了[线程](https://zh.wikipedia.org/wiki/%E7%BA%BF%E7%A8%8B)，并把线程作为操作系统可以进行调度的最小单位。线程使得同一个进程中可以存在多个程序控制流，并且进程内的所有线程会共享进程范围内的资源，并且获得操作系统的调度。只是每个线程都有各自的程序计数器、栈以及局部变量而已(在JVM上面创建的Java线程默认占用的大小是1MB)，这就导致了操作系统在线程之间做切换的时候，仍然会产生切换开销。

某种程度上来讲，并发编程其实就是多线程编程。但是如上所述，由于线程有一定的开销，所以并不是线程越多，并发性能就越好。举例来讲，早期的线程化的WEB框架(例如Tomcat)是这样运行的，当有请求进来的时候，首先是由一个接收线程进行接收，然后放入连接队列里面进行排队，然后再由请求处理线程来进行处理。每一个请求对应一个线程，请求越多的时候线程越多，直到达到线程池的最大线程数。而这个时候，如果仍然有新的请求进来，则会一直放入连接队列里面，直到队列排满为止，再多的请求就被丢失了。Tomcat的默认线程池大小是200MB，然后可以同时处理200个请求。但是如果在一瞬间有10000个请求进来的话，则tomcat可能需要新建非常多的线程、占用非常多的内存来处理这些请求。而且由于线程较多，线程之间的切换开销又剧增，这就导致CPU处理效率降得更低，服务的响应更慢，甚至可能会发生请求丢失。
![线程化服务器模型](/images/posts/201602/threadedServer.jpg "Threaded Web Server")

然后，在引入线程之后，我们在编程的时候又会遇到如下的一些问题：

1. 安全性问题：当多个线程访问某段程序的时候，可能发生由于线程之间交替的顺序不同，而程序的行为表现不正确的问题；
2. 活跃性问题：当程序在多线程环境下，可能会发生某段应该正确执行的程序永远无法得到执行的情形。具体的情形有死锁、饥饿、活锁等；
3. 性能问题： 设计良好的多线程程序一般会提高程序性能，但是如上面所举的Tomcat的例子，如果线程数量过多，可能会出现频繁的上下文切换操作，带来额外的性能开销，从而导致性能没有对应的提升，反而急剧下降。

综上所述，我们应该就能大体明白并发编程想要解决什么问题。并发编程实际上是在多线程编程的基础上，通过一定的设计模式和手段，在保证程序的安全性、活跃性的基础上，提升程序的执行效率的编程实践。在以前，并发可能是一个“高深的”主题。但是随着计算机往多核发展，我们应该学会如何利用线程来更好地利用这些多出来的核心数。本文的重要参考书[Java并发编程实战](http://jcip.net/)就是专门讲述Java并发编程实践的。建议有空闲的朋友可以仔细读一下。

### 2. Scala在处理并发上面有什么特别的？


