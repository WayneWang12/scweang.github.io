---
layout: page
title: Scala并发编程
time: 2016-02-13 20:33:00
---

在Java编程里面，并发编程一直被看作是一门高大上的内容。主要原因在于编写正确的并发程序相对于单线程程序来说，基本上难出一个数量级。又由于Java相对来说比较啰嗦，编写并发程序的时候又会导致额外的代码，所以部分人不太愿意写并发程序。但是随着现代计算机往多核发展，应用可能服务的用户数量成几何指数增加，为了更好地利用硬件资源，编写并发程序，应该要成为程序员的基本素养。

Scala赖以成名的一大优点就是其对并发编程的高级抽象。借助于Scala的函数式的特性，编写并发程序变得前所未有的轻松简单。当然，在这之前，还是必须了解并发编程需要解决什么样的问题，并且横向地和Java做一下对比，这样我们才能知道，为什么Scala在这一块有优势。

### 1. 什么是并发编程

远古时代的计算机不包含操作系统，它们从头到尾只执行一个程序，并且这个程序能访问计算机中的所有资源。在这种裸机环境里面，不仅很难编写和运行程序，而且每次运行只能有一个程序，这对于昂贵并且稀有的计算机资源来说也是一种浪费。而[操作系统](https://zh.wikipedia.org/zh-cn/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F)的出现使得计算机每次能运行多个程序，并且不同的程序都在单独的进程中运行。操作系统会为各个独立执行的进程分配各种资源，包括内存、文件句柄以及安全证书等。如果需要的话，不同的进程还能通过一些粗粒度的通信机制来交换数据，这些机制包括：套接字、信号处理器、共享内存、信号量以及文件等。

之所以在计算机中加入操作系统来实现多个程序的同时执行，主要是基于以下三个原因：

1. 资源利用率：很多情况下，程序必须等待某个外部操作执行完成，例如输入输出操作，而在等待的时候程序无法执行其他任何工作。因此如果在等待的同时可以运行另一个程序，那么无疑可以提高`资源利用率`；
2. 公平性：不同的用户和程序对于计算机上的资源有着同等的使用权，应当保障这些用户和程序能够共享计算机资源，而不是由一个程序从头运行到尾，然后再启动下一个程序；
3. 便利性：通常来说，在计算多个任务的时候，应该编写多个程序，然后在必要的时候相互通信，这比只编写一个程序来计算所有任务更容易实现。

而为了实现以上三点，操作系统提供了[进程](https://zh.wikipedia.org/wiki/%E8%A1%8C%E7%A8%8B)的概念来运行程序。这就保证了计算机的资源在运行的过程中能得到合理的利用，多个程序运行在多个进程里面，然后由操作系统决定哪一个进程占用CPU资源。

但是，仅仅只有进程是不够的。进程负责运行程序，而程序通常可能会有不同的执行路径。如果操作系统是以进程为单位进行调度的话，就意味着每一个CPU时间片里面，程序只能有一条路径得到执行，而这就阻止了程序更好地利用CPU的可能性。就好比，你打开音箱听歌，然后开始玩手机。这个时候不仅能享受音乐的美妙，你也从玩手机的过程中得到了快感。这种情形下，你打开音箱的操作就是一个并发的操作。你在相同的时间里面完成了两件事情，玩手机和听音乐，而这主要归功于你的大脑可以同时完成这两件事情。可是假设你是计算机里面双核CPU，玩手机和听音乐是一个程序里面的两条路径。但是由于操作系统只能按照进程进行调度，所以当轮到你的程序得到调度的时候，要么是你在玩手机，要么是你在听音乐。明明是可以同时执行的两个任务，却只能依次来做，实在令人郁闷。而为了解决这个问题，伟大的计算机科学家们发明了[线程](https://zh.wikipedia.org/wiki/%E7%BA%BF%E7%A8%8B)，并把线程作为操作系统可以进行调度的最小单位。线程使得同一个进程中可以存在多个程序控制流，并且进程内的所有线程会共享进程范围内的资源，也能获得操作系统的调度。这时候，你只需要在玩手机的时候起一个听音乐的线程，玩手机和听音乐就能同时获得CPU的资源，在你的大脑里面得到处理。只是每个线程都有各自的程序计数器、栈以及局部变量而已(在JVM上面创建的Java线程默认占用的大小是1MB)，这就导致了操作系统在多个线程之间做切换的时候，仍然会产生切换开销。

某种程度上来讲，并发编程其实就是多线程编程。但是如上所述，由于线程有一定的开销，所以并不是线程越多，并发性能就越好。举例来讲，早期的线程化的WEB框架(例如Tomcat)是这样运行的，当有请求进来的时候，首先是由一个接收线程进行接收，然后放入连接队列里面进行排队，然后再由请求处理线程来进行处理。每一个请求对应一个线程，请求越多的时候线程越多，直到达到线程池的最大线程数。而这个时候，如果仍然有新的请求进来，则会一直放入连接队列里面，直到队列排满为止，再多的请求就被丢失了。Tomcat的默认线程池大小是200MB，然后可以同时处理200个请求。但是如果在一瞬间有10000个请求进来的话，则tomcat可能需要新建非常多的线程、占用非常多的内存来处理这些请求。而且由于线程较多，线程之间的切换开销又剧增，这就导致CPU处理效率降得更低，服务的响应更慢，甚至可能会发生请求丢失。
![线程化服务器模型](/images/posts/201602/threadedServer.jpg "Threaded Web Server")

然后，在引入线程之后，我们在编程的时候又会遇到如下的一些问题：

1. 安全性问题：当多个线程访问某段程序的时候，可能发生由于线程之间交替的顺序不同，而程序的行为表现不正确的问题；
2. 活跃性问题：当程序在多线程环境下，可能会发生某段应该正确执行的程序永远无法得到执行的情形。具体的情形有死锁、饥饿、活锁等；
3. 性能问题： 设计良好的多线程程序一般会提高程序性能，但是如上面所举的Tomcat的例子，如果线程数量过多，可能会出现频繁的上下文切换操作，带来额外的性能开销，从而导致性能没有对应的提升，反而急剧下降。

综上所述，我们应该就能大体明白并发编程想要解决什么问题。并发编程实际是通过一定的设计模式和手段，在保证程序的安全性、活跃性的基础上，提升程序的执行效率的多线程编程实践。在以前，并发可能是一个“高深的”主题。但是随着计算机往多核发展，我们应该学会如何利用线程来更好地利用这些多出来的核心数。本文的重要参考书[Java并发编程实战](http://jcip.net/)就是专门讲述Java并发编程实践的。建议有空闲的朋友可以仔细读一下。

### 2. 什么是异步编程

并发和异步通常是绑定在一起的两个概念。很多时候人们不太清楚这两者之间的区别，所以习惯喊并发编程叫做异步并发编程。某种程度上来说，这两者是等价的，因为通常来讲程序的异步性得到提高，程序的并发性也能得到提高。但是并发编程要解决的问题主要是在多线程环境下的程序执行的安全性、活跃性问题，而异步是并发编程的一个主要手段。往往异步就意味着程序的主线程在执行的过程中是非阻塞的，也就是是说，无论程序执行了什么操作，都不会卡在这个操作上苦苦等待结果，而是继续执行下一步操作。为什么需要异步呢？可以先看一下[下表](http://norvig.com/21-days.html#answers)：

------|--------
CPU执行一般的指令|1/1,000,000,000 sec = 1 nanosec
从L1缓存读取数据|0.5 nanosec
[分支预测错误](https://en.wikipedia.org/wiki/Branch_misprediction)|5 nanosec
从L2缓存读取数据|7 nanosec
互斥锁/解锁|25 nanosec
从主存读取数据|100 nanosec
通过千兆网络发送2KB数据|20,000 nanosec
从主存顺序读取1MB的数据|250,000 nanosec
硬盘寻址|8,000,000 nanosec
从硬盘顺序读取1MB的数据|20,000,000 nanosec
从美国向欧洲发送数据包|150 milliseconds = 150,000,000 nanosec

这是计算机在执行某些操作的时候的一些时间的大概估计。从表中可以看出来，计算机执行一般的指令和进行文件读取或者网络IO的时候所花费的时间的差异可以达到6~9个数量级之多。所以，在进行IO操作的时候，采用异步的方式往往会急剧提升程序的执行效率。伟大的计算机科学家们也因为深知这种差异明显，所以将IO的处理工作从CPU当中分离出来，通过[DMA](https://zh.wikipedia.org/zh-cn/%E7%9B%B4%E6%8E%A5%E8%A8%98%E6%86%B6%E9%AB%94%E5%AD%98%E5%8F%96)来管理计算机系统的IO操作。当遇到IO操作的时候，计算机可以只向DMA发送IO指令，然后由DMA来处理相关操作，当操作完成以后，再以中断的方式向通知CPU。而在这个过程当中，CPU不需要等待就可以继续往下面执行指令。然后再在得到通知的时候，执行IO完成以后应该要执行的指令。

在早期的操作系统里面，通常将可创建的线程数量限制在一个较低的阈值内，因此难以为每一个IO操作创建一个新的线程。这时候就必须使用复杂性远远高于同步IO的非阻塞IO。Java提供`java.nio`来处理这个问题。




