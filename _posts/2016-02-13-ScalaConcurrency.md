---
layout: page
title: Scala并发编程
time: 2016-02-13 20:33:00
---

在Java编程里面，并发编程一直被看作是一门高大上的内容。主要原因在于编写正确的并发程序相对于单线程程序来说，基本上难出一个数量级。又由于Java相对来说比较啰嗦，编写并发程序的时候又会导致额外的代码，所以部分人不太愿意写并发程序。但是随着现代计算机往多核发展，应用可能服务的用户数量成几何指数增加，为了更好地利用硬件资源，编写并发程序，应该要成为程序员的基本素养。

Scala赖以成名的一大优点就是其对并发编程的高级抽象。借助于Scala的函数式的特性，编写并发程序变得前所未有的轻松简单。这篇博文就希望向大家介绍一下Scala在并发编程上面的优势。当然，在这之前，还是必须了解并发编程需要解决什么样的问题，并且横向地和Java做一下对比，这样我们才能知道，为什么Scala在这一块有优势。

### 1. 什么是并发编程

远古时代的计算机不包含操作系统，它们从头到尾只执行一个程序，并且这个程序能访问计算机中的所有资源。在这种裸机环境里面，不仅很难编写和运行程序，而且每次运行只能有一个程序，这对于昂贵并且稀有的计算机资源来说也是一种浪费。而[操作系统](https://zh.wikipedia.org/zh-cn/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F)的出现使得计算机每次能运行多个程序，并且不同的程序都在单独的进程中运行。操作系统会为各个独立执行的进程分配各种资源，包括内存、文件句柄以及安全证书等。如果需要的话，不同的进程还能通过一些粗粒度的通信机制来交换数据，这些机制包括：套接字、信号处理器、共享内存、信号量以及文件等。

之所以在计算机中加入操作系统来实现多个程序的同时执行，主要是基于以下三个原因：

1. 资源利用率：很多情况下，程序必须等待某个外部操作执行完成，例如输入输出操作，而在等待的时候程序无法执行其他任何工作。因此如果在等待的同时可以运行另一个程序，那么无疑可以提高`资源利用率`；
2. 公平性：不同的用户和程序对于计算机上的资源有着同等的使用权，应当保障这些用户和程序能够共享计算机资源，而不是由一个程序从头运行到尾，然后再启动下一个程序；
3. 便利性：通常来说，在计算多个任务的时候，应该编写多个程序，然后在必要的时候相互通信，这比只编写一个程序来计算所有任务更容易实现。

而为了实现以上三点，操作系统提供了[进程](https://zh.wikipedia.org/wiki/%E8%A1%8C%E7%A8%8B)的概念来运行程序。这就保证了计算机的资源在运行的过程中能得到合理的利用，多个程序运行在多个进程里面，然后由操作系统决定哪一个进程占用CPU资源。

但是，仅仅只有进程是不够的。进程负责运行程序，而程序通常可能会有不同的执行路径。如果操作系统是以进程为单位进行调度的话，就意味着每一个CPU时间片里面，程序只能有一条路径得到执行，而这就阻止了程序更好地利用CPU的可能性。就好比，你打开音箱听歌，然后开始玩手机。这个时候不仅能享受音乐的美妙，你也从玩手机的过程中得到了快感。这种情形下，你打开音箱的操作就是一个并发的操作。你在相同的时间里面完成了两件事情，玩手机和听音乐，而这主要归功于你的大脑可以同时完成这两件事情。可是假设你是计算机里面双核CPU，玩手机和听音乐是一个程序里面的两条路径。但是由于操作系统只能按照进程进行调度，所以当轮到你的程序得到调度的时候，要么是你在玩手机，要么是你在听音乐。明明是可以同时执行的两个任务，却只能依次来做，实在令人郁闷。而为了解决这个问题，伟大的计算机科学家们发明了[线程](https://zh.wikipedia.org/wiki/%E7%BA%BF%E7%A8%8B)，并把线程作为操作系统可以进行调度的最小单位。线程使得同一个进程中可以存在多个程序控制流，并且进程内的所有线程会共享进程范围内的资源，也能获得操作系统的调度。这时候，你只需要在玩手机的时候起一个听音乐的线程，玩手机和听音乐就能同时获得CPU的资源，在你的大脑里面得到处理。只是每个线程都有各自的程序计数器、栈以及局部变量而已(在JVM上面创建的Java线程默认占用的大小是1MB)，这就导致了操作系统在多个线程之间做切换的时候，仍然会产生切换开销。

某种程度上来讲，并发编程其实就是多线程编程。但是如上所述，由于线程有一定的开销，所以并不是线程越多，并发性能就越好。举例来讲，早期的线程化的WEB框架(例如Tomcat)是这样运行的，当有请求进来的时候，首先是由一个接收线程进行接收，然后放入连接队列里面进行排队，然后再由请求处理线程来进行处理。每一个请求对应一个线程，请求越多的时候线程越多，直到达到线程池的最大线程数。而这个时候，如果仍然有新的请求进来，则会一直放入连接队列里面，直到队列排满为止，再多的请求就被丢失了。Tomcat的默认线程池大小是200，然后每个线程占用1MB内存，可以同时处理200个请求。这就是说，如果在一瞬间有10000个请求进来的话，只会有200个请求得到处理，然后多余的请求会在连接队列里面排队。这个时候，如果排队的时间过长，则请求可能会因为超时而被丢失。可是这个时候又不能通过多增加线程来解决。线程池如果调整到更大的话，不仅服务占用的内存增多，线程之间的切换开销又导致CPU的处理效率降低，这就会使得服务的响应更慢，甚至失去响应。
![线程化服务器模型](http://scweang.me/images/posts/201602/threadedServer.jpg "Threaded Web Server")

所以，盲目增加线程并不是解决性能问题的万能灵药。只有合理地分析线程的用途，选择合适大小的线程池，并且通过一些细致的处理解决引入线程带来的问题，你的程序才会有一个比较好的提升。

那么，引入线程之后，我们在编程的时候会遇到什么样的问题呢？如下：

1. 安全性问题：当多个线程访问某段程序的时候，可能发生由于线程之间交替的顺序不同，而程序的行为表现不正确的问题；
2. 活跃性问题：当程序在多线程环境下，可能会发生某段应该正确执行的程序永远无法得到执行的情形。具体的情形有死锁、饥饿、活锁等；
3. 性能问题： 设计良好的多线程程序一般会提高程序性能，但是如上面所举的Tomcat的例子，如果线程数量过多，可能会出现频繁的上下文切换操作，带来额外的性能开销，从而导致性能没有对应的提升，反而急剧下降。

综上所述，我们应该就能大体明白并发编程想要解决什么问题。并发编程实际是通过一定的设计模式和手段，在保证程序的安全性、活跃性的基础上，提升程序的执行效率的多线程编程实践。在以前，并发可能是一个“高深的”主题。但是随着计算机往多核发展，我们应该学会如何利用线程来更好地利用这些多出来的核心数。本文的重要参考书[Java并发编程实战](http://jcip.net/)就是专门讲述Java并发编程实践的。建议有空闲的朋友可以仔细读一下。

### 2. 什么是异步编程

并发和异步通常是绑定在一起的两个概念。很多时候人们不太清楚这两者之间的区别，所以习惯喊并发编程叫做异步并发编程。某种程度上来说，这两者是等价的，因为通常来讲程序的异步性得到提高，程序的并发性也能得到提高。但是并发编程要解决的问题主要是在多线程环境下的程序执行的安全性、活跃性问题，而异步是并发编程的一个主要手段。往往异步就意味着程序的主线程在执行的过程中是非阻塞的，也就是是说，无论程序执行了什么操作，都不会卡在这个操作上苦苦等待结果，而是继续执行下一步操作。当异步操作结束以后，再通过副作用或者回调来通知主线程，又或者直接结束，什么也不做。

为什么需要异步呢？可以先看一下[下表](http://norvig.com/21-days.html#answers)：

操作 | 耗时
------|--------
CPU执行一般的指令|1/1,000,000,000 sec = 1 nanosec
从L1缓存读取数据|0.5 nanosec
[分支预测错误](https://en.wikipedia.org/wiki/Branch_misprediction)|5 nanosec
从L2缓存读取数据|7 nanosec
互斥锁/解锁|25 nanosec
从主存读取数据|100 nanosec
通过千兆网络发送2KB数据|20,000 nanosec
从主存顺序读取1MB的数据|250,000 nanosec
硬盘寻址|8,000,000 nanosec
从硬盘顺序读取1MB的数据|20,000,000 nanosec
从美国向欧洲发送数据包|150 milliseconds = 150,000,000 nanosec

这是计算机在执行某些操作的时候的一些时间的大概估计。从表中可以看出来，计算机执行一般的指令和进行文件读取或者网络IO的时候所花费的时间的差异可以达到6~9个数量级之多。所以，在进行IO操作的时候，采用异步的方式往往会急剧提升程序的执行效率。伟大的计算机科学家们也因为深知这种差异明显，所以将IO的处理工作从CPU当中分离出来，通过[DMA](https://zh.wikipedia.org/zh-cn/%E7%9B%B4%E6%8E%A5%E8%A8%98%E6%86%B6%E9%AB%94%E5%AD%98%E5%8F%96)来管理计算机系统的IO操作。当遇到IO操作的时候，计算机可以只向DMA发送IO指令，然后由DMA来处理相关操作，当操作完成以后，再以中断的方式通知CPU。而在这个过程当中，CPU不需要等待就可以继续往下面执行指令。然后再在得到通知的时候，执行IO完成以后应该要执行的指令。

在早期的操作系统里面，通常将可创建的线程数量限制在一个较低的阈值内，因此难以为每一个IO操作创建一个新的线程。这时候就必须使用复杂性远远高于同步的异步IO。Java提供`java.nio`包来处理这个问题。而现代操作系统相对来说没有这个担心，因为系统可以创建的线程数量往往达到十数万以上，所以为每一个IO操作分配一个线程也是可行的。

但是，如第一节所说，由于线程切换的开销的存在，保证自己的线程池在比较小的规模是非常好的编程实践。因此，虽然异步IO会增加程序的复杂度，但是诸如由于netty、mina等框架在现在不仅没有没落，反而受到越来越多的重视，并且在对应的高性能领域里面大放光彩。

然后，不仅仅只是IO。假如你的程序有某一步计算的耗时非常大，像这种CPU密集型的操作也可以通过异步的方式挂起，等到计算完成以后，再来处理结果。

至于如何理解阻塞非阻塞和同步异步之间的区别，建议查看知乎上面的这个回答:https://www.zhihu.com/question/19732473/answer/20851256

至此，大致讲了一下并发和异步。在下一节，会接着讲一下Scala是如何处理安全性问题，并且尽量和Java做一个清晰的对比。


### 3. 在Scala中并发

某种程度上讲，并发问题主要的场景就是可变状态的共享。可变状态的共享会发生什么问题呢？我们可以举一个生活中很形象的例子来比喻。譬如我现在正坐在咖啡厅写这篇博客，朋友给我打电话问我在哪里，我告诉了他，然后他跟我说他准备过来强迫我请他喝咖啡（我怎么尽是这样的朋友）。由于我是个比较健忘（或者说故意忘记的，哼）的人嘛，咖啡喝完了博客写差不多了，我就跑旁边健身中心游泳去了，手机锁在了更衣室柜子里面。然后游泳完了以后，打开手机，发现了十几个未接来电，和微信上的一张绝交的表情图。因为没有将我的状态变动共享出去，我和朋友之间友谊的小船说翻就翻了，这样的后果真是普大喜奔，哦不，是惨不可言。所以，在和朋友交往的过程中，记得要多交流多通信息，这样你们友谊的小船才有可能进化成基情的巨轮。

由此来理解在多个线程中共享一个可变的状态情景。在编程的过程中，经常会发生一种“check-then-act”的情景。就好像上面说的那个情景，朋友先给我打电话检查一下我的位置状态，然后赶过来准备强迫我请喝咖啡。但是在他准备赶过来的过程中，我的状态发生了变化，而他持有的还是一个旧的状态。所以在调用强迫我请喝咖啡的函数的时候，抛出了异常，打翻了小船。这种“check-then-act”的情形，在多线程环境下，叫做“竞态条件”。竞态条件的消除是并发编程里面的一个重要课题，在这里不准备展开，只是说一下主要的解决手段是利用锁来进行的。用锁来解决竞态条件是个非常需要技巧和经验的手段。锁的粒度如果过粗，很容易使得程序的并发性下降，降低计算机资源的利用率；而锁的粒度如果过细而且设计的不够好的话，则可能会发生诸如死锁这样的绝境。只有合理地设计锁的粒度，才能在程序的正确性和性能上，达到一个好的提升，而这样的设计，对于一般的程序员（包括我）来说，可能要求有点高。

那么，Scala里面如何解决这样的问题呢？两个方法：

1. 共享的状态不可变；
2. 可变的状态不共享。

在Scala里面，定义一个不可变的状态比Java中轻松太多。什么样才算是一个不可变的状态呢？作为状态的一个对象不可变，则其满足如下三个条件：

1. 该对象所有的状态在构建之后就不可以被修改；
2. 它所有的字段都是final的，以及
3. 它被正确地构建了（也就是说在构建的时候，该对象的引用没有发生逃逸）。

这样的不可变对象，在Java里面可能是这样定义的：

{% highlight java %}
public class ImmutablePeople {
  private final String name;
  private final String location;

  public ImmutableUser(String name, String location) {
    this.name = name;
    this.location = location;
  }

  public String getName() {
    return name;
  }

  public String getLocation() {
    return location;
  }
  
}
{% endhighlight %}

而在Scala里面，则只需要这样：
{% highlight scala %}
case class ImmutablePeople(name:String, location:String)
{% endhighlight %}

Scala的case class还给我们提供一个这样的便利。就是假如People的地点变化了以后，你可以通过如下代码直接提供一个新的对象：
{% highlight scala %}
val wayne = ImmutablePeople("Wayne", "cafe")
val swimmingWayne = wayne.copy(location = "gym")
{% endhighlight %}

其中changedWayne称作是wayne的一个新的快照。使用不可变的对象并不意味着在Scala里面你不变动任何一个状态。相反地，我们只是提供一个这个时间这个状态的一个快照。而这样的与时间相对应的快照更加符合现实，也就是说你所观察到的是此时此刻的这个状态。而你可以根据这个状态做出自己此时的下一步反应，而不用担心这个状态发生变化。拿上面的例子做对比，这就好比我是一个会分身术的人，朋友给我打电话的时候，我就变出了一个在咖啡厅里面一直喝咖啡的我，然后程序的下一步我又复制了一个移动到健身中心健身的我，这样一来，一个我来招呼朋友，一个我去健身游泳，这样就满足了并发性，又可以保证友谊的小船还能稳当行驶不翻船。
{% highlight scala %}
val wayne = ImmutableUser("Wayne", "abc@scweang.me")
friend.callAndThreat(wayne)
val swimmingWayne = wayne.copy(location = "gym")
swimming(swimmingWayne)
{% endhighlight %}

当然，像这样的不变对象有时候是满足不了程序世界的要求的。不变是很好的，但是很多时候，有一些状态必须是变化的。例如一个账户里面的资金数额，你只能读取当前状态做操作，而不能随意地去读取之前的状态来进行处理（要不然我就一直用我最有钱时候的账户去买东西了）。遇到这样的情况Scala是怎么解决的呢？那就是使用Actor。

Actor说起来并不是一个很新颖的技术模型。早在1973年，Actor model就被提出，之后被Erlang借鉴，用来构建了一个稳定性达到99.9999%的电信系统。但是由于Erlang主要只是很小众的一部分人在使用，所以Actor模型一直不温不火。近期Actor之所以重新火起来，一是因为最近的计算机往多核发展，大家在寻找并发解决方案的时候想起来了Actor，另外就是因为Scala对函数式的支持导致用Actor模型来写代码变得简单可行，并且产生了一个非常强大的开源库Actor库：[Akka](http://akka.io)。

那么，什么是Actor呢？

Scala之前在标准库里面带有一个自己实现的Actor模型。但是后来由于Akka的出现，Scala将自己的Actor库废弃了，并推荐大家使用Akka。Akka的Actor说白了，就是一个只有一个调用方法的对象。你与这个对象的所有交互只能通过向它发送消息来进行，而不能有其他任何的途径。假设你持有了一个Actor对象的引用，你只能通过如下方式跟这个Actor进行通信：
{% highlight scala %}
actor ! "Hello!"
{% endhighlight %}















